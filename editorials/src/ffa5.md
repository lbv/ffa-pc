This time we had 19 participants; thanks to everyone who joined the contest.

Congratulations to Alexander Vints from Ukraine, who solved the complete
problem set and finished in first place.

- - -


### A - The Weight of a Brick ###
*Tried by 15 participants*.
*Number of ACs: 13*.
*Sample solution*:
[`brick.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/a-brick/code/brick.cpp)

A basic math problem. A little algebra should show that the answer (let's
call it W) is:

<div style="display:block;text-align:left"><img
src="http://mathurl.com/9fqwdgq.png" border="0"></div>

To simplify the answer (turn it into two coprimes **p** and **q**)
simply divide the numerator and denominator by their
[GCD](http://en.wikipedia.org/wiki/Greatest_common_divisor).


### B - Lincoln's Rail Puzzle ###
*Tried by 10 participants*.
*Number of ACs: 8*.
*Sample solution*:
[`lincoln.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/b-lincoln/code/lincoln.cpp)

The way to maximise the area enclosed by a group of lines all of the same
length is by forming a regular polygon with them. In other words, the
closest you can get to a circle, the more area you're enclosing.

A little trigonometry can be used to deduce the formula, but just in case
you need a little help, this is it:

<div style="display:block;text-align:left"><img
src="http://mathurl.com/9vuc8mp.png" border="0"></div>


### C - Rip Van Winkle Puzzle ###
*Tried by 1 participant*.
*Number of ACs: 1*.
*Sample solution*:
[`winkle.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/c-winkle/code/winkle.cpp)

This is somewhat similar to the
[Treblecross](http://lbv-pc.blogspot.com/2012/07/treblecross.html) problem.
This is also an impartial game that can be analysed with the Sprague--Grundy
theorem. All winning moves have to be identified by checking every possible
move and verifying if the resulting "nimber" is zero (which means a losing
configuration for the opponent).


### D - The Leaning Tower of Pisa ###
*Tried by 6 participants*.
*Number of ACs: 6*.
*Sample solution*:
[`pisa.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/d-pisa/code/pisa.cpp)

This one I consider a very pretty mathematics problem. Its solution can be
discovered by a little algebraic manipulation over the series that describes
the distance travelled by the ball. This process might look something like
this (where **S** denotes the answer):

<div style="display:block;text-align:left"><img
src="http://mathurl.com/9amnrom.png" border="0"></div>

The rest is simply formatting the answer, making the conversion into feet
and inches.


### E - The Royal Road to Learning (I) ###
*Tried by 15 participants*.
*Number of ACs: 15*.
*Sample solution*:
[`royal1.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/e-royal1/code/royal1.cpp)

This is a classical problem known as the [Lazy caterer's
sequence](http://en.wikipedia.org/wiki/Lazy_caterer%27s_sequence) or the
[Pancake--cutting
problem](http://demonstrations.wolfram.com/PancakeCuttingProblem/). For a
nice explanation of how to deduce the solution starting with a recursive
formulation, see [Concrete
Mathematics](http://en.wikipedia.org/wiki/Concrete_Mathematics), section
1.2.

See also the problem *Pizza Cutting* (UVa ID 10079).


### F - The Royal Road to Learning (II) ###
*Tried by 2 participants*.
*Number of ACs: 1*.
*Sample solution*:
[`royal2.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/f-royal2/code/royal2.cpp)

This problem is about obtaining all primitive [Pythagorean
triples](http://en.wikipedia.org/wiki/Pythagorean_triple) with sides less
then a million.

There is a simple mechanism to obtain these triples which is credited to
Euclid. Just choose two integers **m** and **n** with *m > n*, and then you
can obtain the triple (a, b, c) as follows:

<div style="display:block;text-align:left"><img
src="http://mathurl.com/8kh732g.png" border="0"></div>

Which is a nice set of relations that are easy to remember because they
look very similar to the resulting terms after expanding a binomial to the
power of two.

*m* and *n* are sometimes called the *generators* of a triple. Another
interesting fact about this process, which is relevant to this problem, is
that using Euclid's method produces all possible primitive triples; which
means all triples where the GCD of all sides is 1. It can
also produce non-primitive triples, but it's easy to filter them out.
Quoting from Wikipedia:

> The triple generated by Euclid's formula is primitive if and only if *m* and
> *n* are coprime and *m âˆ’ n* is odd.


### G - The Ferry Boat Problem ###
*Tried by 2 participants*.
*Number of ACs: 1*.
*Sample solution*:
[`ferry.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/g-ferry/code/ferry.cpp)

Sam Loyd's explanation of this problem is remarkably good at showing how
solving algebraic problems usually involves intuition and a good model of the
problem, and how those things are much more important that simply memorizing
rules and equations. You can find it in his
[*Cyclopedia*](http://www.mathpuzzle.com/loyd/).

Anyway, one way to deduce the answer could look like this. Let's call **W**
the width of the river, **v~1~** and **v~2~** the speeds of the boats, and
let's say that the time from the start to the moment the boats meet for the
first time is **t~1~**, and the time when they meet for the second time is
**t~2~**. Then we have:

<div style="display:block;text-align:left"><img
src="http://mathurl.com/8qw6j2c.png" border="0"></div>

From this it can be seen that either the width of the river is zero (which
does not make sense, so that solution is discarded), or it's *3A - B*, which
is the solution we want.


### H - The Little Brown Jug ###
*Tried by 1 participant*.
*Number of ACs: 1*.
*Sample solution*:
[`jug.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/h-jug/code/jug.cpp)

This is one of my favourite problems from this contest. It can be solved
with dynamic programming, using an *O(L^3)* algorithm. It can also be solved
in *O(k L^2)* (where *L=2k + 1*), because of the symmetry of a palindrome:
if you know the number of ways to read half the word, then that is the same
number of ways to read the second half.


### I - Problems of History ###
*Tried by 8 participants*.
*Number of ACs: 5*.
*Sample solution*:
[`history.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/i-history/code/history.cpp)

This is not a very difficult problem, but it does require some caution
because a naive solution can easily exceed the memory limit. Since the
number of permutations of the first 9 positive digits is not very large (*9!
= 362880*), you can pre--calculate all the rationals that can be formed with
those permutations (making sure to discard any rational greater than or
equal to one), and store them in a hash map or something similar.


### J - In Puzzleland (I) ###
*Tried by 1 participant*.
*Number of ACs: 1*.
*Sample solution*:
[`puzzleland1.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/j-puzzleland1/code/puzzleland1.cpp)

This one is related to the [coin change
problem](http://www.algorithmist.com/index.php/Coin_Change), but first it
requires to compute all the results that are possible from a single toss.
This should reveal that using only one die it is possible to make any score
in the range (-10 : 3), some scores in more than one way.

Then just use dynamic programming to find the number of ways to make each
score with a certain number of dice.


### K - In Puzzleland (II) ###
*Tried by 19 participants*.
*Number of ACs: 17*.
*Sample solution*:
[`puzzleland2.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/k-puzzleland2/code/puzzleland2.cpp)

One of the easiest problem of this contest. It involves a standard
change--of--base. However, note that the answer may not fit in a basic data
type (not even a 64--bit variable), so it's better to store it in an array
of characters or something like that.


### L - Milkman's Puzzle ###
*Tried by 1 participant*.
*Number of ACs: 1*.
*Sample solution*:
[`milkman.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/l-milkman/code/milkman.cpp)

A Breadth First Search problem, where the solution must be built with care
to make sure that it's the lexicographically lowest alternative.


### M - The Missing Number ###
*Tried by 5 participants*.
*Number of ACs: 3*.
*Sample solution*:
[`missing.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/m-missing/code/missing.cpp)

This is a very interesting puzzle by Mr. Loyd. The core of this problem is
noticing that the sum of the first 9 positive integers is equal to 45, which
is a multiple of 9. Now, all numbers divisible by 9 have a peculiar
characteristic: the sum of their digits is also divisible by 9. For example,
for 45, 4 + 5 = 9.

This means that the professor's trick is simply adding the remaining digits,
and finding out the difference between that number and the next multiple of
9.


### N - Thanksgiving Turkey ###
*Tried by 1 participant*.
*Number of ACs: 1*.
*Sample solution*:
[`thanksgiving.cpp`](https://github.com/lbv/ffa-pc/blob/master/ffa5-sam-loyds-puzzle-carnival/n-thanksgiving/code/thanksgiving.cpp)

This is another of my favourites from this contest. Initially I thought that
it would just require a simple backtracking algorithm, finding each
individual shot one at a time. However, this turned out to be too slow
(which should not be a surprise after a little complexity analysis).

However, there is an elegant way to solve it faster. Since there are only
300 possible scores that can be reached with 6 shots, you can pre--calculate
all possible combinations of six shots, and use that to answer the test
cases.
